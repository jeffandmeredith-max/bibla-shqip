/**
 * fetch-playlist.mjs
 *
 * Fetches all videos from the YouTube playlist using yt-dlp,
 * parses chapter timestamps, groups videos by month, and writes
 * src/data/january.js, src/data/february.js, etc. automatically.
 *
 * Run: node scripts/fetch-playlist.mjs
 * Called automatically by: npm run build
 */

import { execSync, spawnSync } from 'child_process'
import { writeFileSync, readFileSync, mkdirSync, readdirSync, existsSync } from 'fs'
import { join, dirname } from 'path'
import { fileURLToPath } from 'url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const ROOT = join(__dirname, '..')
const DATA_DIR = join(ROOT, 'src', 'data')

const PLAYLIST_URL = 'https://www.youtube.com/playlist?list=PL-20shMe4LIKvWmIz3sSlq_RH-IaqIR5_'

// Albanian month names → key used in the app
const MONTH_MAP = {
  'Janar':   { key: 'january',   label: 'Janar',   exportName: 'january'   },
  'Shkurt':  { key: 'february',  label: 'Shkurt',  exportName: 'february'  },
  'Mars':    { key: 'march',     label: 'Mars',    exportName: 'march'     },
  'Prill':   { key: 'april',     label: 'Prill',   exportName: 'april'     },
  'Maj':     { key: 'may',       label: 'Maj',     exportName: 'may'       },
  'Qershor': { key: 'june',      label: 'Qershor', exportName: 'june'      },
  'Korrik':  { key: 'july',      label: 'Korrik',  exportName: 'july'      },
  'Gusht':   { key: 'august',    label: 'Gusht',   exportName: 'august'    },
  'Shtator': { key: 'september', label: 'Shtator', exportName: 'september' },
  'Tetor':   { key: 'october',   label: 'Tetor',   exportName: 'october'   },
  'Nëntor':  { key: 'november',  label: 'Nëntor',  exportName: 'november'  },
  'Dhjetor': { key: 'december',  label: 'Dhjetor', exportName: 'december'  },
}

// Try to find yt-dlp — check PATH first, then the WinGet install location
function getYtDlpPath() {
  const candidates = [
    'yt-dlp',
    'C:/Users/jeffa/AppData/Local/Microsoft/WinGet/Packages/yt-dlp.yt-dlp_Microsoft.Winget.Source_8wekyb3d8bbwe/yt-dlp.exe',
  ]
  for (const c of candidates) {
    try {
      execSync(`"${c}" --version`, { stdio: 'pipe' })
      return c
    } catch {}
  }
  // On CI (Netlify/GitHub Actions), yt-dlp is installed via pip
  return 'yt-dlp'
}

function fetchPlaylist(ytdlp) {
  console.log('⏳ Fetching playlist metadata…')
  // Use spawnSync so stdout and stderr are captured separately,
  // and non-zero exit codes (private video errors) don't throw.
  const result = spawnSync(
    ytdlp,
    ['--print', '%(id)s|||%(title)s|||%(chapters)s', '--no-download', '--ignore-errors', PLAYLIST_URL],
    { encoding: 'utf8', maxBuffer: 10 * 1024 * 1024 }
  )
  if (!result.stdout || result.stdout.trim() === '') {
    console.warn('⚠ yt-dlp produced no output (YouTube may be blocking this IP).')
    console.warn('  stderr:', result.stderr?.slice(0, 300))
    console.warn('  Falling back to existing committed data files — skipping fetch.')
    return null
  }
  return result.stdout
}

function parseTitle(title) {
  // Title format: "[Kalendari i Leximit të Biblës] 17 Shkurt"
  // or "[Kalendari i Leximit t? Bibl?s] 17 Shkurt" (encoding issue in some terminals)
  const match = title.match(/\]\s*(\d+)\s+(\S+)\s*$/)
  if (!match) return null
  return { day: parseInt(match[1], 10), monthName: match[2] }
}

function parseChapters(chaptersStr) {
  if (!chaptersStr || chaptersStr === 'NA' || chaptersStr === 'None') return []
  // Parse Python-style list of dicts
  const entries = []
  const re = /\{'start_time':\s*([\d.]+),\s*'title':\s*'([^']+)',\s*'end_time':\s*([\d.]+)\}/g
  let m
  while ((m = re.exec(chaptersStr)) !== null) {
    entries.push({
      title: fixEncoding(m[2]),
      start: Math.round(parseFloat(m[1])),
    })
  }
  return entries
}

function fixEncoding(str) {
  // Fix common encoding artifacts from yt-dlp on Windows
  return str
    .replace(/ZANAFLLA/g, 'Zanafilla')
    .replace(/Zanaflla/gi, 'Zanafilla')
    .replace(/ZANAFILLA/g, 'Zanafilla')
    .replace(/MATEU/g, 'Mateu')
    .replace(/MARKU/g, 'Marku')
    .replace(/LUKA/g, 'Luka')
    .replace(/VEPRAT/g, 'Veprat')
    .replace(/EZRA/g, 'Ezdra')
    .replace(/EZDRA/g, 'Ezdra')
    .replace(/NEHEMIA/g, 'Nehemia')
    .replace(/ESTERI/g, 'Esteri')
    .replace(/JOBI/g, 'Jobi')
    .replace(/ROMAK[^\s]VE/gi, 'Romakëve')
    .replace(/ROMAKËVE/g, 'Romakëve')
    .replace(/1 E KORINTASVE/g, '1 e Korintasve')
    .replace(/2 E KORINTASVE/g, '2 e Korintasve')
    .replace(/GALATASVE/g, 'Galatasve')
    .replace(/EFESIANËVE/g, 'Efesianëve')
    .replace(/FILIPIANËVE/g, 'Filipianëve')
    .replace(/KOLOSIANËVE/g, 'Kolosianëve')
    .replace(/HYRJE/gi, 'Hyrje')
    // Title-case anything still fully uppercased
    .replace(/\b([A-ZËÇ]{2,})\b/g, (w) => w[0] + w.slice(1).toLowerCase())
    .trim()
}

function generateDataFile(exportName, entries) {
  const lines = [
    `// Auto-generated by scripts/fetch-playlist.mjs — do not edit manually`,
    `export const ${exportName} = ${JSON.stringify(entries, null, 2)}`,
  ]
  return lines.join('\n') + '\n'
}

function generateIndexFile(months) {
  const imports = months
    .map((m) => `import { ${m.exportName} } from './${m.exportName}'`)
    .join('\n')

  const entries = months
    .map((m) => `  { key: '${m.key}', label: '${m.label}', days: ${m.exportName} }`)
    .join(',\n')

  return [
    `// Auto-generated by scripts/fetch-playlist.mjs — do not edit manually`,
    imports,
    '',
    `export const MONTHS = [\n${entries}\n]`,
    '',
  ].join('\n')
}

// Build a lookup of existing audio files: e.g. { 'january-1': 'january-1.webm' }
// Falls back to scanning the committed data files for known audioFile fields.
function getAudioMap() {
  const audioDir = join(ROOT, 'public', 'audio')
  const map = {}

  // Scan local audio directory if present
  if (existsSync(audioDir)) {
    for (const file of readdirSync(audioDir)) {
      const base = file.replace(/\.[^.]+$/, '')
      map[base] = file
    }
    return map
  }

  // On CI (no local audio dir), parse existing data files to preserve audioFile fields
  const dataDir = join(ROOT, 'src', 'data')
  if (existsSync(dataDir)) {
    for (const file of readdirSync(dataDir)) {
      if (!file.endsWith('.js') || file === 'months.js') continue
      const content = readFileSync(join(dataDir, file), 'utf8')
      for (const match of content.matchAll(/"audioFile":\s*"([^"]+)"/g)) {
        const audioFile = match[1]
        const base = audioFile.replace(/\.[^.]+$/, '')
        map[base] = audioFile
      }
    }
  }
  return map
}

// ── Main ──────────────────────────────────────────────────────────────────────

const ytdlp = getYtDlpPath()
const raw = fetchPlaylist(ytdlp)

// If yt-dlp was blocked/failed, use the existing committed data files as-is
if (raw === null) {
  console.log('✅ Using existing data files. Vite build will proceed normally.')
  process.exit(0)
}

// Group by month
const byMonth = {}
const audioMap = getAudioMap()

for (const line of raw.split('\n')) {
  if (!line.includes('|||')) continue
  const [id, title, chaptersStr] = line.split('|||')
  if (!id || !title) continue

  const parsed = parseTitle(title)
  if (!parsed) { console.warn(`  ⚠ Could not parse title: "${title.trim()}"`) ; continue }

  const { day, monthName } = parsed
  const monthInfo = MONTH_MAP[monthName]
  if (!monthInfo) { console.warn(`  ⚠ Unknown month: "${monthName}"`) ; continue }

  const readings = parseChapters(chaptersStr)
  // Skip the intro-only "HYRJE" chapter if it's the only item
  const filteredReadings = readings.filter((r) => r.title.toLowerCase() !== 'hyrje' || readings.length === 1)

  // Check if an audio file exists for this day e.g. "january-1.webm"
  const audioKey = `${monthInfo.key}-${day}`
  const audioFile = audioMap[audioKey] || null

  const entry = {
    day,
    date: `${day} ${monthName}`,
    videoId: id.trim(),
    readings: filteredReadings,
  }
  if (audioFile) entry.audioFile = audioFile

  if (!byMonth[monthName]) byMonth[monthName] = []
  byMonth[monthName].push(entry)
}

// Sort each month's entries by day number
for (const key of Object.keys(byMonth)) {
  byMonth[key].sort((a, b) => a.day - b.day)
}

// Write data files
mkdirSync(DATA_DIR, { recursive: true })

const monthOrder = Object.keys(MONTH_MAP)
const presentMonths = monthOrder
  .filter((m) => byMonth[m] && byMonth[m].length > 0)
  .map((m) => MONTH_MAP[m])

for (const monthInfo of presentMonths) {
  const entries = byMonth[monthInfo.label]
  const content = generateDataFile(monthInfo.exportName, entries)
  const filePath = join(DATA_DIR, `${monthInfo.exportName}.js`)
  writeFileSync(filePath, content, 'utf8')
  console.log(`✓ ${filePath.replace(ROOT, '.')} — ${entries.length} days`)
}

// Write the months index
const indexContent = generateIndexFile(presentMonths)
writeFileSync(join(DATA_DIR, 'months.js'), indexContent, 'utf8')
console.log(`✓ src/data/months.js — ${presentMonths.length} months`)

console.log('\n✅ Done.')
